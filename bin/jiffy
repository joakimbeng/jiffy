#!/usr/bin/env node

var dir = process.cwd(),
    join = require('path').join,
    ext = require('path').extname,
    base = require('path').basename,
    dirname = require('path').dirname,
    fs = require('klei-fs'),
    exists = fs.existsSync,
    ncp = require('ncp').ncp,
    marked = require('marked'),
    kleiDust = require('klei-dust'),
    pkg = require('../package.json'),
    url = require('url'),
    hljs = require('highlight.js'),
    q = require('q'),
    truncate = require('html-truncate'),
    complete = require('../lib/complete'),
    extend = require('../lib/extend'),
    settings = require('../lib/settings');

console.log('          __  __');
console.log('     / Â´ /_  /_');
console.log('  __/ / /   /  /__/  v.' + pkg.version);
console.log('               __/');
console.log('');

settings = settings(dir);

if (!exists(settings.postsDir))
  throw new Error('Missing posts directory: "' + settings.postsDir + '"');

var started = Date.now();
console.log('started');


if (!exists(settings.buildDir)) {
  console.log('Creating build directory...');
  fs.mkdirSync(settings.buildDir, function (err) {
    if (err) throw err;
  });
}

if (!exists(settings.cssDir)) {
  console.log('Creating css directory...');
  fs.mkdirSync(settings.cssDir, function (err) {
    if (err) throw err;
  });
}

if (!exists(settings.fontDir)) {
  console.log('Creating font directory...');
  fs.mkdirSync(settings.fontDir, function (err) {
    if (err) throw err;
  });
}

if (!exists(join(settings.buildDir, 'tags'))) {
  console.log('Creating tags directory...');
  fs.mkdirSync(join(settings.buildDir, 'tags'), function (err) {
    if (err) throw err;
  });
}

if (!exists(join(settings.buildDir, 'posts'))) {
  console.log('Creating posts directory...');
  fs.mkdirSync(join(settings.buildDir, 'posts'), function (err) {
    if (err) throw err;
  });
}

if (!exists(join(settings.buildDir, 'category'))) {
  console.log('Creating category directory...');
  fs.mkdirSync(join(settings.buildDir, 'category'), function (err) {
    if (err) throw err;
  });
}


kleiDust.setOptions({
  root: settings.templateDir,
  useHelpers: true
});

var highlight = function(code, lang){
  if(!hljs) return code;
  if(lang === undefined || !hljs.LANGUAGES[lang]){
    lang = hljs.highlightAuto(code).language;
    if(!lang) return code;
  }
  return hljs.highlight(lang, code).value;
};


function getPostDate(dir) {
  return base(dir).split(' - ')[0];
}

function nameToFileName (dir, name) {
  return join(dir, urlFriendlyName(name) + '.html');
}

function nameToUrl (dir, name) {
  return dir + '/' + urlFriendlyName(name) + '.html';
}

function urlFriendlyName (name) {
  return name.toLowerCase().split(' ').join('-');
}

fs.readJson = function (file, cb) {
  fs.readFile(file, 'utf-8', function (err, source) {
    if (err) return cb(err);
    return cb(null, JSON.parse(source));
  });
};

var readDir = q.denodeify(fs.readdir);
var readFile = q.denodeify(fs.readFile);
var readJson = q.denodeify(fs.readJson);
var stat = q.denodeify(fs.stat);
var dust = q.denodeify(kleiDust.dust);
var writeFile = q.denodeify(fs.writeFile);
var copy = q.denodeify(ncp);

function isJson (file) {
  return ext(file) === '.json';
}

function isMarkdown (file) {
  return ['.md', '.markdown'].indexOf(ext(file)) >= 0;
}


var postsPromise = readDir(settings.postsDir).then(function (postDirs) {
  return q.all(postDirs.map(function (dir) {
    var post = {};
        post.name = getPostName(dir);
        post.date = getPostDate(dir);
        post.url = nameToUrl('posts', post.name);
        post.fileName = nameToFileName('posts', post.name);

    var markdown = q.defer(),
        created = q.defer(),
        meta = q.defer();

    var hasPost = false,
        hasMeta = false;

    readDir(join(settings.postsDir, dir)).then(function (files) {
      files.forEach(function (fileName) {
        var file = join(settings.postsDir, dir, fileName);
        if (isMarkdown(file)) {
          hasPost = true;
          markdown.resolve(readFile(file, 'utf-8'));
          stat(file).then(function (stats) {
            created.resolve(stats.ctime);
          });
        } else if (isJson(file)) {
          hasMeta = true;
          meta.resolve(readJson(file));
        }
      });
      if (!hasPost)
        markdown.reject(new Error('Missing content (markdown file) for post: ' + post.name));
      if (!hasMeta)
        meta.resolve({});
    });

    post.markdown = markdown.promise;
    post.created = created.promise;
    post.content = getHtml(markdown.promise);
    post.shortContent = getShortHtml(post.content);
    post.category = getCategory(meta.promise);
    post.author = getAuthor(meta.promise);
    post.tags = getTags(meta.promise);

    return complete(post);
  }));
});


function getPostName(dir) {
  return base(dir).split(' - ').slice(1).join(' - ');
}

function getHtml (markdown) {
  var html = q.defer();
  if (q.isPromise(markdown)) {
    markdown.then(function (markdown) {
      compileMarkdown(html, markdown);
    });
  } else {
    compileMarkdown(html, markdown);
  }
  return html.promise;
}

function getShortHtml (html) {
  if (!settings.truncate)
    return html;

  var shortHtml = q.defer();
  if (q.isPromise(html)) {
    html.then(function (code) {
      shortHtml.resolve(truncate(code, settings.truncate));
    });
  } else {
    shortHtml.resolve(truncate(code, settings.truncate));
  }
  return shortHtml.promise;
}

function compileMarkdown (htmlDeferred, markdown) {
  setTimeout(function () {
    var result = marked(markdown, {highlight: highlight});
    htmlDeferred.resolve(result);
  });
}

function getCategory (meta) {
  return meta.then(function (meta) {
    var name = meta.category || 'Uncategorized';
    return {
      name: name,
      url: nameToUrl('category', name),
      fileName: nameToFileName('category', name)
    };
  });
}

function getAuthor (meta) {
  return meta.then(function (meta) {
    return settings.getAuthor(meta.author);
  });
}

function getTags (meta) {
  return meta.then(function (meta) {
    return (meta.tags || []).map(function (name) {
      return {
        name: name,
        url: nameToUrl('tags', name),
        fileName: nameToFileName('tags', name)
      };
    });
  });
}

postsPromise.then(function (posts) {
  var promises = [];

  var data = {
    blogTitle: settings.title,
    blogUrl: settings.url,
    blogProtocol: url.parse(settings.url).protocol || 'http://',
    disqusShortname: settings.disqusShortname
  };

  var tags = {};

  posts.forEach(function (post) {
    post.tags.forEach(function (tag) {
      if (!tags[tag.name])
        tags[tag.name] = {posts: [], tag: tag};
      tags[tag.name].posts.push(post);
    });
  });

  var categories = {};

  posts.forEach(function (post) {
    if (!categories[post.category.name])
      categories[post.category.name] = {posts: [], category: post.category};
    categories[post.category.name].posts.push(post);
  });

  data.tags = Object.keys(tags).map(function (tag) {
    return tags[tag];
  });
  data.categories = Object.keys(categories).map(function (category) {
    return categories[category];
  });

  promises.concat(data.tags.map(function (tag) {
    var tagData = extend({path: '../', currentUrl: tag.tag.url}, tag, data);

    return dust('tag', tagData).then(function (out) {
      return writeFile(join(settings.buildDir, tagData.tag.fileName), out, 'utf-8');
    });
  }));

  promises.concat(data.categories.map(function (category) {
    var categoryData = extend({path: '../', currentUrl: category.category.url}, category, data);

    return dust('category', categoryData).then(function (out) {
      return writeFile(join(settings.buildDir, categoryData.category.fileName), out, 'utf-8');
    });
  }));

  promises = posts.map(function (post) {
    var postData = extend({post: post, path: '../', currentUrl: post.url}, data);

    return dust('post', postData).then(function (out) {
      return writeFile(join(settings.buildDir, post.fileName), out, 'utf-8');
    });
  });

  var indexData = extend({posts: posts}, data);

  var indexPromise = dust('index', indexData).then(function (out) {
    return writeFile(join(settings.buildDir, 'index.html'), out, 'utf-8');
  });

  promises.push(indexPromise);

  return q.all(promises);
}).then(function () {
  console.log('done', Date.now() - started);
});


// Copy css:
copy(join(settings.templateDir, 'css'), settings.cssDir)
  .then(function () {
    console.log('Css files copied...');
  });

// Copy fonts:
copy(join(settings.templateDir, 'font'), settings.fontDir)
  .then(function () {
    console.log('font files copied...');
  });

