#!/usr/bin/env node

var dir = process.cwd(),
    join = require('path').join,
    ext = require('path').extname,
    base = require('path').basename,
    dirname = require('path').dirname,
    fs = require('klei-fs'),
    exists = fs.existsSync,
    marked = require('marked'),
    kleiDust = require('klei-dust'),
    pkg = require('../package.json'),
    url = require('url'),
    hljs = require('highlight.js'),
    q = require('q');

console.log('          __  __');
console.log('     / ´ /_  /_');
console.log('  __/ / /   /  /__/  v.' + pkg.version);
console.log('               __/');
console.log('');

var settings;
try {
  settings = require(join(dir, 'jiffy.json'));
} catch (e) {
  throw new Error('No jiffy.json found in current folder!');
}

if (!settings.title)
  throw new Error('Your blog needs a title, missing "title" in jiffy.json!');

if (!settings.url)
  throw new Error('Your blog needs an url, missing "url" in jiffy.json!');

if (!settings.authors)
  throw new Error('Your blog needs at least one author! Missing "authors" in jiffy.json!');

if (!settings.authors.length)
  throw new Error('Your blog needs an author! "authors" cannot be empty!');

if (settings.authors.length > 1 && !hasDefaultAuthor())
  console.warn('When more than one author exists, it\'s good to mark one of them as default, with "default": true');

function hasDefaultAuthor () {
  return settings.authors.length === 1
      || settings.authors.some(function (author) {
           return author.default;
         });
}

function getDefaultAuthor () {
  if (settings.authors.length === 1)
    return settings.authors[0];
  return settings.authors.filter(function (author) {
    return author.default;
  })[0];
}

function getAuthor (identifier) {
  return settings.authors.filter(function (author) {
    return author.identifier === identifier;
  })[0];
}

// Defaults:
settings.dirs = settings.dirs || {};

var postsDir = join(dir, settings.dirs.posts || 'posts'),
    buildDir = join(dir, settings.dirs.build || 'build'),
    templateDir = join(__dirname, '..', 'templates'),
    cssDir = join(buildDir, 'css');

if (!exists(postsDir))
  throw new Error('Missing posts directory: "' + postsDir + '"');

var started = Date.now();
console.log('started');


if (!exists(buildDir)) {
  console.log('Creating build directory...');
  fs.mkdirSync(buildDir, function (err) {
    if (err) throw err;
  });
}

if (!exists(cssDir)) {
  console.log('Creating css directory...');
  fs.mkdirSync(cssDir, function (err) {
    if (err) throw err;
  });
}

kleiDust.setOptions({root: templateDir});

var async = require('async');



var highlight = function(code, lang){
  if(!hljs) return code;
  if(lang === undefined || !hljs.LANGUAGES[lang]){
    lang = hljs.highlightAuto(code).language;
    if(!lang) return code;
  }
  return hljs.highlight(lang, code).value;
};


function getPostDate(dir) {
  return base(dir).split(' - ')[0];
}

function postNameToFileName (postName) {
  return postName.toLowerCase().split(' ').join('-') + '.html';
}

function complete(obj) {
  var keys = Object.keys(obj);
  // console.log(keys);
  var promises = keys.map(function (key) {
    return obj[key];
  });
  // console.log(promises);
    return q.when(promises, function (promises) {
        var countDown = 0;
        var deferred = q.defer();
        promises.reduce(function (undefined, promise, index) {
            if (q.isFulfilled(promise)) {
                obj[keys[index]] = promises[index] = q.nearer(promise);
            } else {
                ++countDown;
                q.when(promise, function (value) {
                    obj[keys[index]] = promises[index] = value;
                    if (--countDown === 0) {
                        deferred.resolve(obj);
                    }
                }, deferred.reject);
            }
        }, void 0);
        if (countDown === 0) {
            deferred.resolve(obj);
        }
        return deferred.promise;
    });
}

fs.readJson = function (file, cb) {
  fs.readFile(file, 'utf-8', function (err, source) {
    if (err) return cb(err);
    return cb(null, JSON.parse(source));
  });
};

var readDir = q.denodeify(fs.readdir);
var readFile = q.denodeify(fs.readFile);
var readJson = q.denodeify(fs.readJson);
var stat = q.denodeify(fs.stat);
var dust = q.denodeify(kleiDust.dust);
var writeFile = q.denodeify(fs.writeFile);

function isJson (file) {
  return ext(file) === '.json';
}

function isMarkdown (file) {
  return ['.md', '.markdown'].indexOf(ext(file)) >= 0;
}


var postsPromise = readDir(postsDir).then(function (postDirs) {
  return q.all(postDirs.map(function (dir) {
    var post = {};
        post.name = getPostName(dir);
        post.date = getPostDate(dir);
        post.url = postNameToFileName(post.name);

    var markdown = q.defer(),
        created = q.defer(),
        meta = q.defer();

    var hasPost = false,
        hasMeta = false;

    readDir(join(postsDir, dir)).then(function (files) {
      files.forEach(function (fileName) {
        var file = join(postsDir, dir, fileName);
        if (isMarkdown(file)) {
          hasPost = true;
          markdown.resolve(readFile(file, 'utf-8'));
          stat(file).then(function (stats) {
            created.resolve(stats.ctime);
          });
        } else if (isJson(file)) {
          hasMeta = true;
          meta.resolve(readJson(file));
        }
      });
      if (!hasPost)
        markdown.reject(new Error('Missing content (markdown file) for post: ' + post.name));
      if (!hasMeta)
        meta.resolve({});
    });

    post.markdown = markdown.promise;
    post.created = created.promise;
    post.content = getHtml(markdown.promise);
    post.shortContent = getHtml(markdown.promise);
    post.meta = meta.promise;

    return complete(post);
  }));
});


function getPostName(dir) {
  return base(dir).split(' - ').slice(1).join(' - ');
}

function getHtml (markdown) {
  var html = q.defer();
  if (q.isPromise(markdown)) {
    markdown.then(function (markdown) {
      compileMarkdown(html, markdown);
    });
  } else {
    compileMarkdown(html, markdown);
  }
  return html.promise;
}

function compileMarkdown (htmlDeferred, markdown) {
  setTimeout(function () {
    var result = marked(markdown, {highlight: highlight});
    htmlDeferred.resolve(result);
  });
}

/**
 * 1. Ta fram alla inläggsmappar
 * 2. Ta fram information för varje inlägg
 *  a. Läs in markdown
 *  b. Läs in meta
 *  c. Kompilera markdown till html
 * 3. Kompilera dust till html
 */

postsPromise.then(function (posts) {
  var promises = [];

  var indexData = {
    posts: posts,
    blogTitle: settings.title,
    blogUrl: settings.url,
    blogProtocol: url.parse(settings.url).protocol || 'http://',
    disqusShortname: settings.disqusShortname
  };

  promises.push(dust('index', indexData).then(function (out) {
    return writeFile(join(buildDir, 'index.html'), out, 'utf-8');
  }));

  posts.forEach(function (post) {
    var author;
    if (post.meta.author)
      author = getAuthor(post.meta.author);
    else if (hasDefaultAuthor())
      author = getDefaultAuthor();
    if (!author)
      throw new Error('Post: "' + post.name + '" is missing an author, and no default author exists!');

    post.author = author;

    var data = {
      post: post,
      url: post.url,
      blogTitle: settings.title,
      blogUrl: settings.url,
      blogProtocol: url.parse(settings.url).protocol || 'http://',
      disqusShortname: settings.disqusShortname
    };

    promises.push(dust('post', data).then(function (out) {
      return writeFile(join(buildDir, post.url), out, 'utf-8');
    }));
  });

  return q.all(promises);
}).then(function () {
  console.log('done', Date.now() - started);
});


// Copy css:
readDir(join(templateDir, 'css'))
  .then(function (files) {
    return q.all(files.map(function (file) {
      return readFile(join(templateDir, 'css', file))
        .then(function (content) {
          return writeFile(join(cssDir, file), content, 'utf-8');
        });
    }));
  })
  .then(function () {
    console.log('Css files copied...');
  });

