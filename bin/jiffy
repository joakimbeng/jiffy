#!/usr/bin/env node

var dir = process.cwd(),
    join = require('path').join,
    ext = require('path').extname,
    base = require('path').basename,
    dirname = require('path').dirname,
    marked = require('marked'),
    pkg = require('../package.json'),
    url = require('url'),
    q = require('q'),
    truncate = require('html-truncate'),
    fs = require('../lib/fs'),
    dust = require('../lib/dust'),
    highlight = require('../lib/highlight'),
    complete = require('../lib/complete'),
    extend = require('../lib/extend'),
    settings = require('../lib/settings'),
    toArray = require('../lib/to-array'),
    sortBy = require('../lib/sort-by');

console.log('          __  __');
console.log('     / Â´ /_  /_');
console.log('  __/ / /   /  /__/  v.' + pkg.version);
console.log('               __/');
console.log('');

// fs.exists(settings.postsDir).then(function (exists) {
//   if (!exists)
//     throw new Error('Missing posts directory: "' + settings.postsDir + '"');
// });

var started = Date.now();
console.log('started');


function getPostDate(dir) {
  return base(dir).split(' - ')[0];
}

function nameToFileName (dir, name) {
  return join(dir, urlFriendlyName(name) + '.html');
}

function nameToUrl (dir, name) {
  return dir + '/' + urlFriendlyName(name) + '.html';
}

function urlFriendlyName (name) {
  return name.toLowerCase().split(' ').join('-');
}

// var readDir = q.denodeify(fs.readdir);
// var readFile = q.denodeify(fs.readFile);
// var readJson = q.denodeify(fs.readJson);
// var stat = q.denodeify(fs.stat);
// var writeFile = q.denodeify(fs.writeFile);
// var copy = q.denodeify(ncp);

function isJson (file) {
  return ext(file) === '.json';
}

function isMarkdown (file) {
  return ['.md', '.markdown'].indexOf(ext(file)) >= 0;
}


var postsPromise = fs.readDir(settings.postsDir).then(function (postDirs) {
  return q.all(postDirs.map(function (dir) {
    var post = {};
        post.name = getPostName(dir);
        post.date = getPostDate(dir);
        post.url = nameToUrl('posts', post.name);
        post.fileName = nameToFileName('posts', post.name);

    if (dir[0] === '.' || !post.name)
      return;

    var markdown = q.defer(),
        modified = q.defer(),
        meta = q.defer();

    var hasPost = false,
        hasMeta = false;

    fs.readDir(join(settings.postsDir, dir)).then(function (files) {
      files.forEach(function (fileName) {
        var file = join(settings.postsDir, dir, fileName);
        if (isMarkdown(file)) {
          hasPost = true;
          markdown.resolve(fs.readFile(file, 'utf-8'));
          fs.stat(file).then(function (stats) {
            modified.resolve(stats.mtime);
          });
        } else if (isJson(file)) {
          hasMeta = true;
          meta.resolve(fs.readJson(file));
        }
      });
      if (!hasPost)
        markdown.reject(new Error('Missing content (markdown file) for post: ' + post.name));
      if (!hasMeta)
        meta.resolve({});
    });

    post.markdown = markdown.promise;
    post.modified = modified.promise;
    post.content = getHtml(markdown.promise);
    post.shortContent = getShortHtml(post.content);
    post.category = getCategory(meta.promise);
    post.author = getAuthor(meta.promise);
    post.tags = getTags(meta.promise);

    return complete(post);
  }));
});


function getPostName(dir) {
  return base(dir).split(' - ').slice(1).join(' - ');
}

function getHtml (markdown) {
  return markdown.then(function (markdown) {
    return marked(markdown, {highlight: highlight});
  });
}

function getShortHtml (html) {
  if (!settings.truncate)
    return html;

  return html.then(function (code) {
    return truncate(code, settings.truncate);
  });
}

function getCategory (meta) {
  return meta.then(function (meta) {
    var name = meta.category || 'Uncategorized';
    return {
      name: name,
      url: nameToUrl('category', name),
      fileName: nameToFileName('category', name)
    };
  });
}

function getAuthor (meta) {
  return meta.then(function (meta) {
    return settings.getAuthor(meta.author);
  });
}

function getTags (meta) {
  return meta.then(function (meta) {
    return (meta.tags || []).map(function (name) {
      return {
        name: name,
        url: nameToUrl('tags', name),
        fileName: nameToFileName('tags', name)
      };
    });
  });
}

postsPromise.then(function (posts) {
  var promises = [];

  posts = removeInvalidPosts(posts);

  sortBy(posts, '-date', 'name');

  var data = {
    blogTitle: settings.title,
    blogUrl: settings.url,
    blogProtocol: url.parse(settings.url).protocol || 'http://',
    disqusShortname: settings.services.disqus,
    googleAnalytics: settings.services.googleAnalytics,
    tags: sortBy(getTagsFromPosts(posts), 'tag.name'),
    categories: sortBy(getCategoriesFromPosts(posts), 'category.name')
  };

  promises.concat(data.tags.map(function (tag) {
    var tagData = extend({path: '../', currentUrl: tag.tag.url, inTag: true}, tag, data);

    return build(tagData, 'tag', tagData.tag.fileName);
  }));

  promises.concat(data.categories.map(function (category) {
    var categoryData = extend({path: '../', currentUrl: category.category.url, inCategory: true}, category, data);

    return build(categoryData, 'category', categoryData.category.fileName);
  }));

  promises.concat(posts.map(function (post) {
    var postData = extend({post: post, path: '../', currentUrl: post.url, inPost: true}, data);

    return build(postData, 'post', post.fileName);
  }));

  var indexData = extend({posts: posts, inIndex: true}, data);

  var indexPromise = build(indexData, 'index', 'index.html');

  promises.push(indexPromise);

  return q.all(promises);
}).then(function () {
  console.log('done', Date.now() - started);
});

function removeInvalidPosts (posts) {
  return posts.filter(function (post) { return post; });
}

function getTagsFromPosts (posts) {
  var tags = {};

  posts.forEach(function (post) {
    post.tags.forEach(function (tag) {
      if (!tags[tag.name])
        tags[tag.name] = {posts: [], tag: tag};
      tags[tag.name].posts.push(post);
    });
  });

  return toArray(tags);
}

function getCategoriesFromPosts (posts) {
  var categories = {};

  posts.forEach(function (post) {
    if (!categories[post.category.name])
      categories[post.category.name] = {posts: [], category: post.category};
    categories[post.category.name].posts.push(post);
  });

  return toArray(categories);
}

function build (data, template, filename) {
  return dust(template, data).then(function (out) {
    return fs.writeFile(join(settings.buildDir, filename), out, 'utf-8');
  });
}


// Copy assets:
fs.copyDir(join(settings.themeDir, 'assets'), settings.assetsDir)
  .then(function () {
    console.log('Theme assets copied...');
  });

